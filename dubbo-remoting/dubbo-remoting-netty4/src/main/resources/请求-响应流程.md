### 请求流程

  ###### 客户端
  
    1.Client.send-->NettyChannel实例化并缓存-->Channel.writeAndFlush-->客户端线程进入等待状态
      此步骤为客户端应用线程执行
    2.NettyClientHandler处理器执行write方法(数据传输操作)->通过handler(NettyClient)执行sent方法-->ChannelHandler调用链
      此步骤为Netty的业务线程执行(线程模型左侧为Netty线程操作、线程模型右侧由Netty线程还是线程池操作,取决于内存模型的选择,默认为all,表示所有的操作都交予线程池)
    3.sent方法链式调用-->HeartbeatHandler(记录时间戳)-->线程模型-->HeaderExchangeHandler(更新DefaultFuture sent值)
      
  ###### 服务端
    1.NettyServerHandler处理器执行channelRead方法(数据传输操作),并通过channel找到NettyChannel-->Server.received-->ChannelHandler调用链
      此步骤为Netty的业务线程执行(线程模型左侧为Netty线程,右侧取决于线程模型)
    2.received链式调用-->HeartbeatHandler(记录时间戳)-->线程模型-->HeaderExchangeHandler(消息类型为Request)-->单向或双向-->DubboProtocol.requestHandler 执行服务
    
### 响应流程
  ###### 服务端
    1.HeaderExchangeHandler(双向请求,构建Response返回值,发送响应结果)-->NettyChannel.send-->Channel.writeAndFlush
      此步骤为客户端应用线程执行(也有可能是Netty业务线程,取决于线程模型)
    2.同请求流程-客户端-2和3步骤
  ###### 客户端
    1.NettyServerHandler处理器执行channelRead方法(数据传输操作),并通过channel找到NettyChannel-->Server.received-->ChannelHandler调用链
      此步骤为Netty的业务线程执行(线程模型左侧为Netty线程,右侧取决于线程模型)
    2.received链式调用-->HeartbeatHandler(记录时间戳)-->线程模型-->HeaderExchangeHandler(消息类型为Response)-->填充DefaultFuture实例的response字段,并将等待的线程(客户端等待的线程)唤醒
    3.客户端线程响应结果给用户

###### ChannelHandler调用链(连接、断开连接、发送、接收、异常)   

    (NettyClient/NettyServer)->MultiMessageHandler->HeartbeatHandler->线程模型->DecodeHandler->HeaderExchangeHandler->DubboProtocol.requestHandler
                                  (多消息处理)     (心跳处理,接收及相应)                             接收请求并处理
###### 注:
###### 1、以上没有标记为数据传输操作的操作,都属于业务操作。
###### 2、忽略编解码、序列化
###### 3、双向、同步的访问模式                                                 心跳时间的记录及清除                            更新发送数据时间戳、...
